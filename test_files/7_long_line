In computing, a segmentation fault (often shortened to segfault) or access violation is a fault, or failure condition, raised by hardware with memory protection, notifying an operating system (OS) the software has attempted to access a restricted area of memory (a memory access violation). On standard x86 computers, this is a form of general protection fault. The OS kernel will, in response, usually perform some corrective action, generally passing the fault on to the offending process by sending the process a signal. Processes can in some cases install a custom signal handler, allowing them to recover on their own,[1] but otherwise the OS default signal handler is used, generally causing abnormal termination of the process (a program crash), and sometimes a core dump. Segmentation faults are a common class of error in programs written in languages like C that provide low-level memory access. They arise primarily due to errors in use of pointers for virtual memory addressing, particularly illegal access. Another type of memory access error is a bus error, which also has various causes, but is today much rarer; these occur primarily due to incorrect physical memory addressing, or due to misaligned memory access â€“ these are memory references that the hardware cannot address, rather than references that a process is not allowed to address. Many programming languages may employ mechanisms designed to avoid segmentation faults and improve memory safety. For example, the Rust programming language, which appeared in 2010, employs an 'Ownership'[2] based model to ensure memory safety,[3] and garbage collection has been employed since around 1960,[4] which avoids certain classes of memory errors which could lead to segmentation faults.[5]
